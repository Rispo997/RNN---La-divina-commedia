# -*- coding: utf-8 -*-
"""DoubleLSTMgeneration.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qW33xryyye1ZJPMYkuBwrDzpDYb0lp6I
"""

from pickle import load
from keras.models import load_model
from keras.preprocessing.sequence import pad_sequences
from keras.losses import categorical_crossentropy
from tensorflow.math import add, reduce_sum
from tensorflow import constant, float32
import tensorflow
import numpy as np
#Loss
from keras.backend import argmax, get_value
from tensorflow import make_ndarray, make_tensor_proto

def convert_tensor_to_list_of_words(tensor):
  return [word_dict_from_idx[idx] for idx in make_ndarray(make_tensor_proto(argmax(tensor)))]

def custom_loss(y_true, y_pred):
  rhyme_weight = 10
  true = convert_tensor_to_list_of_words(y_true)
  pred = convert_tensor_to_list_of_words(y_pred)
  rhymes_scores = [rhyme_weight*score_rhyme(t, p, enlight_end=1) for t,p in zip(true, pred)]
  s = constant(rhymes_scores, dtype=float32)
  cat_loss = categorical_crossentropy(y_true, y_pred, from_logits=False)
  # tensorflow.print(cat_loss.size)
  return add(s, cat_loss) 

def sample(preds, temperature=0.5):
      # helper function to sample an index from a probability array
    preds = np.asarray(preds).astype('float64')
    preds = np.log(preds) / temperature
    exp_preds = np.exp(preds)
    preds = exp_preds / np.sum(exp_preds)
    probas = np.random.multinomial(1, preds, 1)
    return np.argmax(probas)

#Initialize models
genera_terzina = load_model('/content/weights-55-5.0572.hdf5')
token_terzina = load(open('/content/generaTerzinaTokenizer.pkl', 'rb'))
genera_rima = load_model('/content/model-GeneraRimaWord180Epoch.h5',custom_objects={'custom_loss': custom_loss})
token_rima = load(open('/content/generaRimaWord60.pkl', 'rb'))

SEQ_LEN = 50
genera_terzina_input = ['<start> vita nostra di cammin del mezzo nel _verse_ oscura selva una per ritrovai mi _verse_ smarrita era via diritta la ch√© _verse_ <tercet>']
genera_terzina_input = token_terzina.texts_to_sequences(genera_terzina_input)[0]
genera_terzina_input = [0] * (SEQ_LEN - len(genera_terzina_input)) + genera_terzina_input
genera_rima_input = [token_rima.word_index[word] for word in ['vita', 'oscura', 'smarrita']]
print(genera_terzina_input)
print(genera_rima_input)

n_words = 1500
generated = []
first_word = True
for i in range(n_words):
  if first_word:
    genera_rima_input = np.array(genera_rima_input[-3:]).reshape(1,3)
    prediction = np.argmax(genera_rima.predict(genera_rima_input, verbose=0))
    predicted_word = token_rima.index_word[prediction]
    generated.append(predicted_word)
    genera_rima_input = np.append(genera_rima_input,prediction)
    if predicted_word != "<tercet>":
      first_word = False
      genera_terzina_input = np.append(genera_terzina_input, prediction)
  else:
    # Fix the length of the input sequence
    genera_terzina_input = np.array(genera_terzina_input[-50:]).reshape(1,SEQ_LEN)
    prediction = genera_terzina.predict(genera_terzina_input, verbose=0)[0]
    # Sample and encode the output
    val = sample(prediction)
    predicted_word = token_terzina.index_word[val]
    generated.append(predicted_word)
    genera_terzina_input = np.append(genera_terzina_input, val)
    # print("Parola predetta: " + predicted_word)
    # print("Input Corrente: "+ str(genera_terzina_input))
    if predicted_word == '_verse_' or predicted_word == '<tercet>':
      first_word = True

generated = ['\n' if x=='_verse_' or x=='_end_' or x=='<tercet>' else x for x in generated]
print(generated)
copy = generated.copy()
while copy :
   line = ""
   while copy[0] is not '\n':
    line = copy[0] +" " + line
    copy.pop(0)
   copy.pop(0)
   print(line)